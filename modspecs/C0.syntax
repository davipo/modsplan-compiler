# C0.syntax
# C0 language syntax
# A minimal subset of C

use expr        # common expression syntax


translationunit.root => extdecl+

extdecl => declaration
## extdecl => funcdef
extdecl => statement        ## until we implement functions

declaration => declspecifier initdeclarator,+ ';'

declspecifier => STORAGESPEC? TYPEQUALIFIER* typespecifier

typespecifier => TYPESPEC
## typespecifier => structspecifier
## typespecifier => enumspecifier

initdeclarator => declarator '=' initializer
initdeclarator => declarator

initializer => constantexpr
initializer => '{' designationinitializer,+ ','? '}'

designationinitializer => designation? initializer
designation => designator+ '='

designator => '[' constantexpr ']'
designator => '.' identifier

constantexpr => conditionalexpr_constant
    ## can subtype _constant be used to restrict conditionalexpr?

conditionalexpr_constant => test


declarator => pointr* directdeclarator

pointr => '*' TYPEQUALIFIER*

directdeclarator => identifier followdeclarator*
directdeclarator => '(' declarator ')' followdeclarator*

followdeclarator => identifier
followdeclarator => '(' declarator ')'
followdeclarator => arraydeclarator
followdeclarator => functiondeclarator

arraydeclarator => arrayincomplete
arraydeclarator => arrayvarlen
arraydeclarator => '[' STORAGESPEC? TYPEQUALIFIER* assignexpr ']'
    # STORAGESPEC here may be only 'static'

arrayincomplete => '[' TYPEQUALIFIER* ']'
arrayvarlen => '[' TYPEQUALIFIER*  '*'  ']'

## functiondeclarator => '(' identifier,* ')'
    ## separated param declarations may be too hard to compile
functiondeclarator => '(' paramdeclaration,* ellipsis? ')'

ellipsis => ','  '...'

paramdeclaration => declspecifier+ declarator
    # require a declarator
# paramdeclaration => declspecifier+ declarator?
# paramdeclaration => declspecifier+ abstractdeclarator

# funcdef => declspecifier+ declarator declaration* compoundstatement
    # As specified in C11, but has many constraints not in syntax

funcdef => declspecifier+ identifier functiondeclarator compoundstatement

compoundstatement => '{' blockitem* '}'
blockitem => declaration
blockitem => statement

statement => if
statement => while
statement => for
statement => compoundstatement
statement => expression? ';'

if => 'if' '(' test ')' suite else?
else => 'else' suite

while => 'while' '(' test ')' suite

for => 'for' '(' expression? ';' expression? ';' expression? ')' statement
for => 'for' '(' declaration expression? ';' expression? ')' statement

suite => statement      # for compatibility with base.defn

expression => assignexpr
expression => test      # test specified in expr.syntax

assignexpr => lvalue ASSIGN expression

lvalue => variable

atom => INC_OP variable 
atom => variable INC_OP

