# sbil.defn
# Stack-Based Intermediate Language


use constants   # constant, number


globalvar(type name)
    .addvar(name, type)
    .concat('@', name) '=' type

globalvar(type name constant)
    .addvar(name, type)
    .concat('@', name) '=' type constant


typedef(TYPEID type)
    TYPEID '= type' type


funcdecl(rettype name paramtypes)
    .addvar(name, rettype)
    'declare' .var(name) paramtypes

paramtypes(type,*  ellipsis?)
    '(' .commasep(type*) ellipsis? ')'

ellipsis()
    ',' '...'


funcdef(rettype name params funcbody)
    .addvar(name, rettype)
    .enterscope(name)
    'define' .var(name) params '{'
    .indent()
    &funcbody
    .dedent()
    .exitscope(name)

params(param,* ellipsis?)
    '(' .commasep(param*) ellipsis? ')'


entryblock(instruction* terminator)
    &instruction*
    &terminator

block(label instruction* terminator)
    label ':'
    =entryblock(instruction* terminator)


terminator(return)
    ## Should functions always return a value, to be ignored when return type is void?
    'ret' .top()
    

branch(label label)
    'br' .top(), 'label' .unique(label), 'label' .unique(label)

branch(label)
    'br' 'label' .unique(label)


vardecl(type name)
    .addvar(name, type)
    .concat('%', name) '=' 'alloca' type

vardecl(type name constant)
    =vardecl(type name)
    'store' constant, .var(name)

constval(constant)
    .unique('const') '=' constant

load(variable)
    .unique(variable) '=' 'load' variable

store(variable)
    'store' .top(), variable

cmp(CONDITION)
    .cmp(CONDITION)

call(variable INTEGER)
    .unique(variable) '=' 'call' variable '(' .fnargs(INTEGER) ')'


instruction(BINOP)
    .ssa(BINOP)         # generate static single assignment


STACKOP('pop')
    .pop()              # discard value on top of stack

STACKOP('dup')
    .dup()              # duplicate: push a copy of stack top value on stack


variable(name)
    .var(name)          # type and name
    ## if name is a varargs function, also need function signature type


variable(name subscript)


subscript(variable)


subscript(INTEGER)


