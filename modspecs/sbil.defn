# sbil.defn
# Stack-Based Intermediate Language


use constants   # constant, number


globalvar(type name)
    .addvar(name, type)
    .concat('@', name) '=' type

globalvar(type name constant)
    .addvar(name, type)
    .concat('@', name) '=' type constant


typedef(TYPEID type)
    TYPEID '= type' type


funcdecl(rettype name paramtypes)
    .addvar(name, rettype)
    'declare' .var(name) paramtypes

paramtypes(type,*  ellipsis?)
    '(' .commasep(type*) ellipsis? ')'

ellipsis()
    ',' '...'


funcdef(rettype name params funcbody)
    .addvar(name, rettype)
    .enterscope(name)
    'define' .var(name) params '{'
    .indent()
    &funcbody
    .dedent()
    .exitscope(name)

params(param,* ellipsis?)
    '(' .commasep(param*) ellipsis? ')'


entryblock(instruction* terminator)
    &instruction*
    &terminator

block(label instruction* terminator)
    label ':'
    =entryblock(instruction* terminator)


terminator(return)
    ## Should functions always return a value, to be ignored when return type is void?
    'ret' .top()
    

branch(label label)
    'br' .top(), 'label' .unique(label), 'label' .unique(label)

branch(label)
    'br' 'label' .unique(label)


vardecl(type name)
    .addvar(name, type)
    .concat('%', name) '=' 'alloca' type

vardecl(type name constant)
    =vardecl(type name)
    'store' constant, .var(name)


constval(constant)
    .push(constant)         # push puts type and value on stack

load(variable)
    .load(variable) '=' 'load' variable
    # .load() returns unique 'load' value, pushes it prefixed with dereferenced type

store(variable)
    'store' .top(), variable


cmp(CONDITION)
    .cmp(CONDITION)
    # checks that top 2 values on stack have same type,
    #   returns icmp or fcmp instruction with appropriate condition,
    #   assigning to a unique name, and pushes name prefixed with 'i1' on stack.


call(variable INTEGER)
    .call(variable) '=' 'call' variable '(' .fnargs(INTEGER) ')'
    # .call() returns unique 'call' value, pushes it prefixed with defunced return type


instruction(BINOP)
    .ssa(BINOP)         # generate static single assignment
    # checks that top 2 values on stack have same type, 
    #   returns appropriate ssa instruction, 
    #   assigning to unique BINOP name, pushes it prefixed with type.
    

STACKOP('pop')
    .pop()              # discard value on top of stack

STACKOP('dup')
    .dup()              # duplicate: push a copy of stack top value on stack


variable(name)
    .var(name)          # pointer type and pointer to variable
    ## if name is a varargs function, also need function signature type


variable(name subscript)


subscript(variable)


subscript(INTEGER)


