# c1.syntax
# c1 language syntax
# A working subset of C

use expr        ## common expression syntax


translationunit.root => extdecl+

extdecl => declaration ';'
extdecl => funcdefinition

declaration => typedef
declaration => globalvardeclaration
declaration => funcdeclaration

typedef => 'typedef' typespecifier declarator

globalvardeclaration => typespecifier initdeclarator,+

typespecifier => TYPESPEC
## typespecifier => structspecifier
typespecifier => typedefname

typedefname => identifier

identifier => LOWERNAME


initdeclarator => declarator '=' constantexpr
initdeclarator => declarator

constantexpr => conditionalexpr_constant
    ## use subtype _constant to restrict conditionalexpr?
conditionalexpr_constant => test    # test defined in expr.syntax


declarator => pointr* directdeclarator

pointr => '*' TYPEQUALIFIER*

directdeclarator => identifier followdeclarator*

followdeclarator => arraydeclarator
followdeclarator => functiondeclarator
## followdeclarator => funcdeclarator

arraydeclarator => '[' expression ']'
arraydeclarator => '[' '*'? ']'

## funcdeclarator => '(' paramdecl,* ellipsis? ')'
## paramdecl => declspecifier+ abstractdeclarator
    # Need abstractdeclarator for parameters without name in function declarations


funcdeclaration => typespecifier identifier functiondeclarator

funcdefinition => typespecifier identifier functiondeclarator compoundstatement

functiondeclarator => '(' paramdeclaration,* ellipsis? ')'
    ##  Requires parameters in function declaration to include name, as well as type.

paramdeclaration => declspecifier+ declarator

ellipsis => ','  '...'


compoundstatement => '{' blockitem* '}'
blockitem => declaration
blockitem => statement

statement => if
statement => while
statement => for
statement => compoundstatement
statement => expression? ';'

if => 'if' '(' test ')' suite else?
else => 'else' suite

while => 'while' '(' test ')' suite

for => 'for' '(' expression? ';' expression? ';' expression? ')' statement
for => 'for' '(' declaration expression? ';' expression? ')' statement

suite => statement      # for compatibility with base.defn

expression => assignexpr
expression => test      # test specified in expr.syntax

assignexpr => lvalue ASSIGN expression

lvalue => variable

atom => INC_OP variable 
atom => variable INC_OP

