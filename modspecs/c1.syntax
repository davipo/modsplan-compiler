# c1.syntax
# c1 language syntax
# A working subset of C

use constants   # constant, number
use expr        ## common expression syntax


translationunit.root => extdeclaration+

extdeclaration => typedef ';'
extdeclaration => globalvardeclaration ';'
extdeclaration => funcdeclaration ';'
extdeclaration => funcdefinition


typedef => 'typedef' typespecifier declarator

globalvardeclaration => declspecifier identifier initializer?

declspecifier => STORAGESPEC? TYPEQUALIFIER* typespecifier


typespecifier => TYPESPEC
## typespecifier => structspecifier
typespecifier => typedefname

typedefname => identifier

initializer => '=' constant


declarator => pointr* directdeclarator

pointr => '*' TYPEQUALIFIER*

directdeclarator => identifier followdeclarator*

followdeclarator => arraydeclarator
followdeclarator => functiondeclarator

arraydeclarator => '[' expression ']'
arraydeclarator => '[' '*'? ']'


funcdeclaration => declspecifier identifier functiondeclarator

funcdefinition => declspecifier identifier functiondeclarator compoundstatement

functiondeclarator => '(' paramdeclaration,* ellipsis? ')'
    ##  Requires parameters in function declaration to include name, as well as type.

## functiondeclarator => '(' paramdecl,* ellipsis? ')'     # for parameters without names
## paramdecl => declspecifier+ abstractdeclarator
    # Need abstractdeclarator for parameters without name in function declarations

paramdeclaration => declspecifier+ declarator

ellipsis => ','  '...'


compoundstatement => '{' blockitem* '}'
blockitem => declaration
blockitem => statement

declaration => typespecifier identifier initializer? ';'

statement => if
statement => while
statement => for
statement => compoundstatement
statement => ';'
statement => return ';'
statement => expression ';'

if => 'if' '(' test ')' suite else?
else => 'else' suite

while => 'while' '(' test ')' suite

for => 'for' '(' expression? ';' expression? ';' expression? ')' statement
for => 'for' '(' declaration expression? ';' expression? ')' statement

return => 'return' expression?

suite => statement      # for compatibility with base.defn

expression => assignexpr
expression => test      # test specified in expr.syntax

assignexpr => lvalue '=' expression

lvalue => variable

atom => INC_OP variable 
atom => variable INC_OP

