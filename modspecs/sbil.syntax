# sbil.syntax
# Stack-Based Intermediate Language

# Based on LLVM


use literals        # literal, number, integer, float, string


module.root => definition*

definition => import NEWLINE
definition => constdef NEWLINE
definition => globalvar NEWLINE
definition => typedef NEWLINE
definition => funcdecl NEWLINE      # external or forward declaration
definition => funcdef NEWLINE

import => 'import' module
module => identifier

constdef => 'const' literal         # integer, float, string (pushed on stack)

globalvar => 'var' type name        # at module level, generates a global variable
                            

name => identifier

identifier => LOWERNAME


typedef => 'type' name '=' type

type => numtype
type => pointertype
type => functype
type => arraytype
type => structtype
type => packedstructtype
# type => opaquetype

numtype => INTTYPE          # iN, N = integer
numtype => floattype
floattype => 'half'
floattype => 'float'
floattype => 'double'

pointertype => type '*'

functype => type '(' type,* ')'

arraytype => '[' integer 'x' type ']'

structtype => '{' type,* '}'
packedstructtype = '<{' type,* '}>'

# opaquetype => 'opaque'


funcdecl => 'declare' rettype name paramtypes   # external (or forward?) function
paramtypes => '(' type,*  vararg? ')'

funcdef => 'func' rettype name params funcbody
rettype => 'void'
rettype => type

params => '(' param,*  vararg? ')'
param => type name
vararg => ',' '...'


funcbody => '{' NEWLINE entryblock block* '}'

entryblock => INDENT instruction+ DEDENT

block => label ':' NEWLINE INDENT instruction* DEDENT

label => identifier

instruction => directive NEWLINE
instruction => vardecl NEWLINE
instruction => terminator NEWLINE
instruction => operation NEWLINE

directive => '.' identifier '(' value,* ')'     # compiler directive

vardecl => 'var' type name      # inside a function, generates alloca

terminator => branch
terminator => return

branch => 'br' label ',' label
branch => 'br' label

return => 'ret'

value => directive
value => literal        # integer, float, string
value => variable

variable => name
variable => name subscript       # array or struct element

subscript => '[' value ']'


# All operations assume signed values

operation => 'load' variable
operation => 'store' variable
operation => 'cmp' condition
operation => 'call' name integer    # integer is number of args on stack
operation => binop


# Arithmetic operations (signed values)
binop => 'add'
binop => 'sub'
binop => 'mul'
binop => 'div'
binop => 'rem'

# Bitwise operations
binop => 'shl'
binop => 'lshr'
binop => 'ashr'
binop => 'and'
binop => 'or'
binop => 'xor'

condition => 'eq'
condition => 'ne'
condition => 'lt'
condition => 'le'
condition => 'gt'
condition => 'ge'

