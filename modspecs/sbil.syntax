# sbil.syntax
# Stack-Based Intermediate Language
# Based on LLVM


use constants   # constant, number
use irtype      # intermediate representation types


module.root => definition*

definition => import NEWLINE
definition => constdef NEWLINE
definition => globalvar NEWLINE
definition => typedef NEWLINE
definition => funcdecl NEWLINE      # external or forward declaration
definition => funcdef NEWLINE

import => 'import' module
module => identifier

constdef => 'const' constant        # integer, float, string (generates global variable)

globalvar => 'var' type name                # at module level, generates a global variable
globalvar => 'var' type name '=' constant   # with initializer


name => IDENTIFIER


typedef => 'type' TYPEID '=' type


funcdecl => 'declare' rettype name paramtypes   # external (or forward?) function
paramtypes => '(' type,*  varargs? ')'

funcdef => 'func' rettype name params funcbody
rettype => type

params => '(' param,*  varargs? ')'
param => type name
varargs => ',' '...'


funcbody => '{' NEWLINE entryblock block* '}'

entryblock => INDENT instruction+ terminator DEDENT         # no label

block => label ':' NEWLINE INDENT instruction* terminator DEDENT

label => IDENTIFIER

terminator => branch NEWLINE
terminator => return NEWLINE

branch => 'br' label ',' label      # pop value, jump to first label if true, second if false
branch => 'br' label

return => 'ret'         # 0 or 1 value left on stack, according to rettype;
                        #   check that type matches.


instruction => directive NEWLINE
instruction => vardecl NEWLINE
instruction => load NEWLINE
instruction => store NEWLINE
instruction => cmp NEWLINE
instruction => call NEWLINE
instruction => pop NEWLINE
instruction => BINOP NEWLINE            # binary operation: pop 2 values, leave result

directive => '.' identifier '(' value,* ')'     # compiler directive

vardecl => 'var' type name                  # inside a function, generates alloca
vardecl => 'var' type name '=' literal      #   with initializer

value => directive
value => literal        # integer, float, string
value => variable

variable => name
variable => name subscript       # array or struct element

subscript => '[' value ']'


load => 'load' variable
store => 'store' variable       # pops top value from stack
cmp => 'cmp' CONDITION          # pop 2 values, compare them, leave boolean result
call => 'call' name integer     # integer is number of args on stack
pop => 'pop'                    # discard value on top of stack

