# c1.defn

use base


typedef(typespecifier declarator)
    'type' declarator '=' typespecifier


globalvardeclaration(declspecifier identifier initializer?)
    'var' declspecifier identifier initializer?

initializer(constant)
    '=' constant

declspecifier(STORAGESPEC? TYPEQUALIFIER* typespecifier)
    STORAGESPEC? TYPEQUALIFIER* typespecifier
    ### STORAGESPEC 'static' and TYPEQUALIFIER not handled

STORAGESPEC('extern')
    ''      # external is default linkage


funcdeclaration(declspecifier identifier functiondeclarator)
    'declare' declspecifier identifier functiondeclarator

funcdefinition(declspecifier identifier functiondeclarator compoundstatement)
    'func' declspecifier identifier functiondeclarator '{'
    .indent()
    &compoundstatement
    .return()       # if previous instruction not a terminator and func type is void,
    #                   insert 'ret', else error.
    .dedent()
    '}'

functiondeclarator(paramdeclaration* ellipsis?)
    '(' .commasep(paramdeclaration*) ellipsis? ')'

ellipsis()
    ',' '...'


# local declaration inside a function
declaration(typespecifier identifier initializer?)
    'var' typespecifier identifier initializer?


statement(expression)
    &expression
    'pop'               # discard expression value


do(statement expression)
    'br' do         # terminate previous block
    do:
        .continuebreak(dowhile, doend)
        &statement
        'br' dowhile
    dowhile:        # branch here to continue
        &expression     # while condition
        'br' do, doend
    doend:


for(declaration expression? expression? statement)
    &declaration
    =for(expression? expression? statement)

for(expression? expression? expression? statement)
    &expression?    # initialization, typically an assignment
    'pop'           # discard expression value
    =for(expression? expression? statement)

for(expression? expression? statement)
    'br' for        # terminate previous block
    for:
        &expression?            # condition
        'br' forbegin, forend
    forbegin:
        .continuebreak(for, forend)
        &statement
        &expression?            # next
        'pop'                   # discard expression value
        'br' for
    forend:


continue()
    .continue()

break()
    .break()

return(expression?)
    .returncheck()      # empty only if func type is void
    &expression?
    'ret'
    
    
assignexpr(lvalue expression)
    &expression
    'dup'               # store consumes value, leave a copy
    'store' lvalue


atom(INC_OP variable)   # increment/decrement before use
    'load' variable
    'const 1'
    INC_OP                      # add or subtract
    'dup'                       # leave a copy on stack
    'store' .again(variable)    # reuse variable

atom(variable INC_OP)   # increment/decrement after use
    'load' variable
    'dup'                       # leave a copy on stack
    'const 1'
    INC_OP                      # add or subtract
    'store' .again(variable)    # reuse variable
    
INC_OP('++')
    'add'

INC_OP('--')
    'sub'


TYPESPEC('int')
    'i32'

TYPESPEC('char')
    'i8'

