# L0 token specification

# All characters not recognized become single-character tokens.

# A single uppercase letter denotes a character class; see base.metagrammar.

# Reserved token names: INDENT, DEDENT, NEWLINE
#	These are generated by tokenizer automatically, but disabled by default.
#	Use "enable <name> (, <name>)*" to include these in token stream.
# enable INDENT, DEDENT, NEWLINE
### Enable directive not implemented, these are enabled by default now.


## (not yet implemented) When implemented, move most of this file to base.tokens
# use grammars/base.tokens


STRING => '"' P* '"'
STRING => "'" P* "'"

COMMENT => '#' P*

# P* = any printable characters, must be followed by terminal or end of line.
# (P may be used only with *)
# (See base.metagrammar)


# These are here to expedite parsing (that is, make parse trace easier to read :-)
KEYWORD => 'if'
KEYWORD => 'else'
KEYWORD => 'while'
KEYWORD => 'declare'
KEYWORD => 'external'

RELATION => '=='
RELATION => '!='
RELATION => inequality '='?

inequality => '<'
inequality => '>'

ASSIGN => '='
ASSIGN => '+='
ASSIGN => '-='

ADD_OP => '+'
ADD_OP => '-'

MUL_OP => '*'
MUL_OP => '//' 		# integer division (no FLOAT yet)
## MUL_OP => '/'

BOOL_OP => 'and'
BOOL_OP => 'or'
BOOL_OP => 'not'


# Put this last to recognize keywords, bool_ops
NAME => letter alphanum*

alphanum => letter
alphanum => '_'
alphanum => digit

letter => L 	# lower case character class
letter => U 	# upper case character class

INTEGER => digits

digits => digit+

digit => D		# digit character class, matches any digit

## Put in float module
# May have to parse at higher level, if can't distinguish from INTEGER
# FLOAT => real
# FLOAT => real exponent
# FLOAT => digits exponent
#
# real => digits '.' digits
# exponent => 'E' sign digits
# exponent => 'e' sign digits
# sign => '+'
# sign => '-'

## May need to make E a separate character class.

