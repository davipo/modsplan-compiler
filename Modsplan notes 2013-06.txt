Modsplan notes 2013-06


2013-06-01

How to compile the addressof unary operator in C ('&')?
    Use .addressof() directive, which compiles to .addressof in sbil,
         which uses the value of its arg (must be pointer) in LLVM output.
    This works if argument is an lvalue -- give error otherwise?


Naming defn specs (selecting target)
    Use dash between source and target languages?
        c-sbil.defn compiles C to SBIL
        sbil-llvm.defn compiles SBIL to LLVM
    "Normally" (?), compiler translates to SBIL, and then SBIL to LLVM.
    But it may target a processor more directly.
        sbil-x86.defn, sbil-arm.defn, sbil-propeller.defn? Try these!  ####
    Select target with a command-line option?


Can my compiler translate one higher-level language to another?
    Try L0-js.defn to translate to Javascript? ####
    May need nested signatures (which we may want anyway)  ###


Factor directive handler out of compiler.py?

Use separate class for sbil-llvm directives?
Use Stack class, Symbol class.


2013-06-03

Documentation

    Website
        Description of the project
            Modular specs
                Grammars for syntax and tokens
                Defn spec
                SBIL target language: simple, powerful, translates to LLVM
    
    Tutorial
        Grammar reference
            Write comments in metagrammars -- sufficient?
        Parser finds longest valid alternate
        Defn reference
            Refer to defn.syntax (not user-customizable)
            Explain compiler algorithm
                Depth-first traverse of parse tree, generates defined nodes
            Quantified nodes
            Instructions
                Words
                    Literal
                    Child
                    Directive
                        List & describe
                Expansion
                Rewrite

    To Do
        SBIL to LLVM translator
        XML parse tree output
        More complete and accurate C spec
        Specify other languages
            Demonstrate compiling OO language (Component Pascal, Javascript, Java?)
        Begin structuring a library of modular specs

 
2013-06-04

Eliminate the .root grammar flag?
    Make first nonterm in grammar the root.
    But want to allow 'use' directives at top of file --
        then first production comes from an imported file,
        which is likely not the root.
    
    Can we recognize the first production in the first file read?
        Yes. But then can't put any productions before root.
            (llvm.syntax has two at the top, related to an import.)
        At the end of Grammar.store_production(), substitute:
            "if not self.root and location.filepath == self.filepath:"
            in place of "if 'root' in flags:".
        (Remove all references to root flag, including error in syntax.py)
    
    A compromise: first production is default root, 
        may be overridden with .root flag.


Overloaded operators

    How to select operations based on operand types?
    Considering using flags on grammar nonterms to indicate type.
        May not be needed.

    Use a compiler directive in sbil-llvm.defn to handle type promotion and
        selecting a floating point or integer instruction.
    Except that compiler directives are now limited to one line of code.
    Use two directives:
        .coerce() inserts a sitofp instruction if the top 2 values on stack are
            different types, converting the int to a floating point type.
            (If either not floating point or int, then error.)
            (Error if floating type may be too small for the int type?)
        .ftype('binop') prefixes 'f' to binop if stack top is floating point.
    
    But this does not generalize well for other types (strings?).
    Use a conditional rewrite?
        "=i32=ibinop()" does ibinop if stack top is i32.
    
    Type information comes from constants, and variable and parameter declarations.
    Suppose we propagate a type flag up the parse tree, as such nodes are created. 
        If it finds a node which already has a type, 
            that node and its ancestors are marked NoType, and then can't change.
    When matching signature for code generation, type flags must match.
        (Use .any to match any type, .int to match any int, .string ...)
    





