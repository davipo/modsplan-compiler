Modsplan notes 2013-06


2013-06-01

How to compile the addressof unary operator in C ('&')?
    Use .addressof() directive, which compiles to .addressof in sbil,
         which uses the value of its arg (must be pointer) in LLVM output.
    This works if argument is an lvalue -- give error otherwise?


Naming defn specs (selecting target)
    Use dash between source and target languages?
        c-sbil.defn compiles C to SBIL
        sbil-llvm.defn compiles SBIL to LLVM
    "Normally" (?), compiler translates to SBIL, and then SBIL to LLVM.
    But it may target a processor more directly.
        sbil-x86.defn, sbil-arm.defn, sbil-propeller.defn? Try these!  ####
    Select target with a command-line option?


Can my compiler translate one higher-level language to another?
    Try L0-js.defn to translate to Javascript? ####
    May need nested signatures (which we may want anyway)  ###


Factor directive handler out of compiler.py?

Use separate class for sbil-llvm directives?
Use Stack class, Symbol class.


2013-06-03

Documentation

    Website
        Description of the project
            Modular specs
                Grammars for syntax and tokens
                Defn spec
                SBIL target language: simple, powerful, translates to LLVM
    
    Tutorial
        Grammar reference
            Write comments in metagrammars -- sufficient?
        Parser finds longest valid alternate
        Defn reference
            Refer to defn.syntax (not user-customizable)
            Explain compiler algorithm
                Depth-first traverse of parse tree, generates defined nodes
            Quantified nodes
            Instructions
                Words
                    Literal
                    Child
                    Directive
                        List & describe
                Expansion
                Rewrite

    To Do
        SBIL to LLVM translator
        XML parse tree output
        More complete and accurate C spec
        Specify other languages
            Demonstrate compiling OO language (Component Pascal, Javascript, Java?)
        Begin structuring a library of modular specs

 
2013-06-04

Eliminate the .root grammar flag?
    Make first nonterm in grammar the root.
    But want to allow 'use' directives at top of file --
        then first production comes from an imported file,
        which is likely not the root.
    
    Can we recognize the first production in the first file read?
        Yes. But then can't put any productions before root.
            (llvm.syntax has two at the top, related to an import.)
        At the end of Grammar.store_production(), substitute:
            "if not self.root and location.filepath == self.filepath:"
            in place of "if 'root' in flags:".
        (Remove all references to root flag, including error in syntax.py)
    
    A compromise: first production is default root, 
        may be overridden with .root flag.  ###


Overloaded operators

    How to select operations based on operand types?
    Considering using flags on grammar nonterms to indicate type.

    Could use a compiler directive in sbil-llvm.defn to handle type coercion and
        selecting a floating point or integer instruction.
    Except that compiler directives are now limited to one line of code.
    Use two directives:
        .coerce() inserts a sitofp instruction if the top 2 values on stack are
            different types, converting the int to a floating point type.
            (If either not floating point or int, then error.)
            (Error if floating type may be too small for the int type?)
        .ftype('binop') prefixes 'f' to binop if stack top is floating point.
    
    But this does not generalize well for other types (strings?).
    Use a conditional rewrite?
        "=i32=ibinop()" does ibinop if stack top is i32.
    
    Type information comes from constants, and variable and parameter declarations.
    Suppose we propagate a type flag up the parse tree, as such nodes are created. 
        If it finds a node which already has a type, 
            that node and its ancestors are marked NoType, and then can't change.
    When matching signature for code generation, type flags must match.  ###
        (Use .any to match any type, .int to match any int, .string ...)
    

Language proliferation

    (In case not previously noted here:)
    One hesitation I have about Modsplan is that it could help accelerate a 
    proliferation of languages. I want to see careful improvement, convergence, and 
    standardization of general purpose languages like Python and Scala. If many new 
    languages and dialects proliferate, programmers will need to become more 
    adaptable and multilingual. Readability and proficiency may suffer. I hope Modsplan 
    can at least provide readable specifications to facilitate learning and reference.


Language definition hierarchy

    Early in the conception of Modsplan, I expected to write definitions using a 
    hierarchy of language subsets, each building on the capabilities of the one below.
    Along the way, that idea has receded. One reason is that I want to standardize 
    specifications, so users have less to learn to understand them. But higher-level 
    specs should be easier to read and write. It may be best to build subsets of a 
    typed Python-like language (for readability), and use that to define the rest. 
    (I can try to design it to be a compromise between C++, Java, and Python.)
    
    If Modsplan can translate between higher-level languages, then users can pick 
    a familiar flavor to read their specs in! (Python, Java, C++, Scheme, Haskell?) ####


Discovered more related work: TBNF (similar to my approach), Grammarware, etc.


2013-06-06

Showed Modsplan to Bryan F.
    Shortest C program that crashes: "main ;".
    Random test code generation, for finding C compiler bugs
        (udacity.com course in SW testing)
        John Regehr
        http://www.cs.utah.edu/~regehr/papers/
    Declarations not used in first slot of 'for' statements in C?


Meet with Joe N.
    Documentation
        Dataflow diagram
            Diagramming software?
        Readme
        Website
    Parser/Tokenizer
        Replacement for Yacc/Lex?
        XML parse tree
        Applications?
            Data parsing?
    SBIL-LLVM translator
    


    
    
