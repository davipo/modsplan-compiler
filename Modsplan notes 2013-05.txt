Modsplan notes 2013-05


2013-05-01

Been busy with LED art proposal and img2track knitting machine software.

Defn language

    Looks like I will need to revise the Defn language to generate SBIL and LLVM code.
        It will have a more flexible instruction format, probably simpler, too!

    Been considering allowing nested signatures; might not be hard to implement.


2013-05-02

    Should defn language use quoted strings for literal items?
        Then nonterms and terminals don't need '&' prefix.
        Quoting literals is consistent with syntax specs.


2013-05-03

    Use .error(message) directive to report unsupported features of source language.  ###

    Been worrying about how to distinguish child expansion from substitution of its text.
        I think this is just about when to generate multiple lines of code,
            rather than composing pieces of a single line.
        Thought it might work to expand only when child is the only word on a line.
        But I'm doubting that, finding this very confusing.
            Guess I'll have to sort it out as I implement it.
        If needed, we can use the '&' prefix to signal expansion.


New indenting scheme for SBIL (and LLVM):
    Like LLVM examples I've seen, indent function bodies, except for labels.
        Does LLVM use nested functions? Don't need them now.
    Where handle this in code?
        Could be done after generation, maybe better to keep formatting in one place.
    Rules:
        If line ends with '{', increase indent level.
        If line ends with '}', decrease indent level.
        If line ends with ':', decrease indent just for that line.
        Does a comment at the end of these lines cause a problem?  ###
    

2013-05-06

Progress on expansion/substitution; but not quite clear when expansion needed.  ###

Decided to output terminals directly, no error if they don't appear in defn spec.
    Saves writing a lot of redundant definitions.

Literals in defn specs will be single-quoted. These are output literally (without quotes).
    LITERAL => "'" P* "'"
String contants will be double-quoted. These are output with the quotes.
    STRING => "'" P* "'"


Indenting
    Using .indent() and .dedent() compiler directives (for c1.defn funcdefinition).
        More flexible than recognizing '{' or '}' at end of line.


For C, need to pop stack when the value of an expression is not used.  ####
    This occurs where an expression is a statement,
        and where expressions are used in 'for' statements.
    Solution:
        Expressions always leave result on stack.
        Insert pop instruction where needed to discard value.

2013-05-11

Renamed literals.{syntax, tokens} to constants.*, and 'literal' to 'constant' in specs,
    to avoid confusion with grammar and defn literals.

Use compiler directives for sbil 'const', 'pop', 'var', 'call', etc?
    How recognize them? Don't want to have to put them in defn spec.
Yikes, I'm getting sbil instructions confused with defn instructions!!


Tokenizer

    Do we want to use tokenkinds on the right side of a production in .tokens specs?
    Did I already prove that this was unnecessary?
        Just use a nonterm instead, and add "KINDNAME => nontermname".
    Easier for users without this restriction?   ###
    

2013-05-13

While generating sbil code, why not translate each instruction to LLVM?
    May do this eventually.
    For now, seems simpler to deal with one step at a time.
    Good excercise to use the compiler itself again.
    Syntax, token, and defn specs for sbil are good documentation; use them to verify them.
        Parser will verify correct sbil syntax, produce errors.
    

2013-05-15

Use .label() directive instead of processing branch instructions specially?
    Problem generating llvm 'br' when it's recognized as a BR token.

Fixed problem with comment as first instruction in a definition.
    Improved comment handling.

Tried compiling squares.c1.sbil -- recursion limit exceeded.   ####
    Recursive types in irtype.syntax are the problem, since parser is now greedy,
        trying all alternates to look for the longest parse.
    Want to be able to parse irtype.syntax -- this is the LLVM type syntax.
    Give up greedy parsing, or set limits on it?


2013-05-16

    Unlimited recursion is a problem when an alternate begins with a direct ancestor.
        This occurs in pointertype and functype.
        Avoid the problem by restricting these to types other than pointer or func.
            Can always create a named type (alias) to get the desired type.

    Revised irtypes to constrain types appropriately.
    Revised sbil specs to used constrained types.


Generating LLVM

    Using compiler directives to translate sbil to llvm looks difficult, messy.
    "There's got to be a better way."
    Can we write some kind of defn spec that will generate llvm more directly?
    
    Try writing llvm code in outline form, using llvmpy objects.
    
    Documentation for llvmpy is incomplete.
        How do I make a function declaration?
            Is it just a function without any basicblocks added?
                Yes, good guess -- found that in LLVM Programmer's Manual!
            Forward declaration may not be needed, but external declaration?


2013-05-17

    Building LLVM code with llvmpy looks easier than translating to LLVM Assembler,
        which seems less well specified.
    The LLVM API (and llvmpy wrapper) handles symbols and types.
    The assembler output may also automatically generate names for temporary values,
        but we may want to give more readable names.

    Shall I create compiler directives to generate LLVM objects?

    Complicated stuff is easier to specify with llvmpy objects,
        but simple stuff (types, constants) is more complicated!
    With string-based defn, irtypes needs no defn, types are the same as in sbil;
        but with llvmpy defn, we need to construct Type objects.
    
    With llvmpy defn, we need to extract the types of params to create a function type,
        then set their names after the function is created.

    Could try a mixed approach, using Module.from_assembly() to create some objects.

    Better to generate LLVM without needing to install llvmpy and LLVM.


Comments not working.

2013-05-21

    Rewrote comment handling again.
        Mostly working, but commented out lines in squares.c1 are not output.  ###


2013-05-24

lineparsers.Location object created; revised tokenizer, parser, compiler to use it.


2013-05-26

Revised nextchild() and firstchild() in parsetree to add location arg,
    to produce more useful error messages.

c1.syntax ambiguous, can't distinguish typedefname from identifier with
    "paramdeclaration => declspecifier+ declarator".
    Removed "+" to fix this.

Tried testing multiple parameters of a function.
Problem: missing commas between params.
    Implemented .commasep() directive, then rewrote it to handle c1 params with types.


Add type to L0 params?  ###


What to do next? I want to get a demo working this week.
    Polish c1 to demo a good portion of C?
    Specify another language? (Subset of Java, RPython, Cython, Javascript, Scala, Oberon?)
    Try to implement SBIL to LLVM translator?


2013-05-28

Added do-while statement to c1.
Added continue and break statements to c1.
    Added .continuebreak(), .continue(), .break() directives to compiler to handle them.

### Create base.syntax to hold common features? (Move from expr?)


2013-05-29

### Check that labels are not reused incorrectly in nested loops

Starting to test compiler on more realistic C examples. Issues:  ###

    Multiple declarations on one line
        declaration => declspecifier initdeclarator,+ ';'
        How to apply declspecifier to multiple initdeclarators?
            .forall() compiler directive?

    Implement division and remainder operators
        Caution: these work differently in Python   ###

    Compound ASSIGN_OPs needed ('+=')
    

Error location reporting
    For 'no [unused] child' errors, is it better to report source or defn location?
    (Recently added loc param to nextchild() to allow choosing error location.)
    Source location seems more useful, since defn node is given in error message.


SBIL to LLVM translator

    Needed to implement:
    
        Symbol table with scoping
            Handle globals
        
        Stack, holding name and type
        
        Uniquing for value names (generalize new_label() method)
        
        Compiler directives or code to recognize and handle various instruction types:
            pop, dup
            const
            load, store
            BINOP
            call
            return
            branch


2013-05-30

It is difficult to proofread SBIL to check for proper compilation.
    Would reading LLVM be any easier? I doubt it.
    But at least LLVM can be executed, for testing.


Assignment (expression or statement?)

    Too many dup, store, pop sequences in generated SBIL.  ###
        These are generated from assignment statements.
    
    In C, an assignment is an expression, so we must allow for using its value.
        (Proabably most common use of value is multiple assignment.)
        If store consumes (pops) the value stored, we must dup it.
            If not used (almost always), must discard it with pop.
        If store does not pop the value stored, then we must discard it when not used.
        Can multiple assignment reload the value that was just stored?
            Or insert 'dup' before last store?
        Because a statement in C can be an expression, which can be an assignment,
            it is difficult or impossible to parse assignment statements separately.

    Altenative c1 spec for assignment (statement, not expression):
        This removes excess dup and pop intructions, 
            but won't handle some assignment expressions.

        If we remove "expression => assignexpr", then the 'for' statement needs revision:
            for => 'for' '(' assignment? ';' expression? ';' assignment? ')' statement
                (Assignment nonterm won't allow a function call by itself -- not good.)

        statement => assignment ';'
        assignment => lvalue '=' midlvalue=* expression

        assignment(lvalue  midlvalue* expression)
            &expression
            &midlvalue*
            &lvalue

        midlvalue(variable)
            'dup'
            =lvalue(variable)
        
        lvalue(variable)
            'store' variable

    Not using this now; better to implement C more correctly.
        Can use it for L0 and Cython later.  ###


2013-05-31

Bug: comment repeated when node reused with .again() directive.  ###

Multiple declarations on one line are working.

Implemented more operators for languages L0 and c1:
    Compound assignment operators ('+=')
    Boolean operators (not correct for C or Python, but OK)
    Bitwise NOT ('~')


