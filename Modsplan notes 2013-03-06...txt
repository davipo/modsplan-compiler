Modsplan notes 2013-03-06..


2013-03-06

Took a week to get comment parsing done; didn't work on it much until yesterday. Hard to decide where to handle them (nonterm, alternate, item). Parser still needs cleanup (maxtokens, newtoken).  ###

Simplified syntax specs (including defn.syntax) without COMMENT, eliminating endline.

Implemented enable commands for tokens specs to turn on newline or indent/dedent tokens.
    Default is now to suppress these.
    Turned them both on in L0.tokens and defn.tokens, left both off in C0.tokens.


2013-03-07

Spent a lot of time on C0 specs, rewriting the not-so-readable syntax from the C11 standard. My quantifiers allow much simplification, improving clarity.

The official syntax of C is way too permissive, does not express many constraints. 
Examples:

    funcdef => declspecifier+ declarator declaration* compoundstatement
    The declarator here is a general one, might not be a function at all!
    
    assignment_expression
        : conditional_expression
        | unary_expression assignment_operator assignment_expression
    The first alternate might not include an assignment.
    In the second, a unary_expression can be many things that cannot be assigned to.
    

Wrote squares.{L0, C0}, revised C0 (& L0) specs to compile them correctly.

Next: implement for loops; then functions?


Decided to implement error display of source line with column pointer.
    Not hard, requires saving lines of all current files.
    But to format errors properly, need to clean up error code.

Cleaned up error handling; using just one Error class, in lineparsers.
Error display seems to be working. Tested all 22 errors (fixed a couple).

Python unittest doc is insufficient, unclear how to test compiling a list of files as separate tests. (Can't figure out how to pass a filename in!)

Added some blank lines for readability.


2013-03-08

Tackling the C language for loop. Can't rewrite to a while, because need to insert the third clause at the end of statement suite.

More C syntax confusion:

    Where is a declaration used without an initdeclarator? C11 spec says:
        declaration: declaration-specifiers init-declarator-list? ;

    initializer: assignment-expression
        What does this mean? Arbitrary assignments can be done inside an initializer?
    
    
Been thinking we need a way to substitute params in a rewrite instruction.



To generate code for an initdeclarator with an initializer (int i = 0), we need to get the variable name to add the symbol, but also use it to do an assignment. Need to get content without consuming the node. Maybe compiler directives should not consume their args.

We could add a switch to nextchild to not consume children.
    
Got a 'for' statement to compile correctly!

Comments appear in the wrong place though.  [fixed 2013-03-19]

Need to specify number of args for call. Maybe:
    call .numargs(arg*)
    Or push a value on stack that indicates number of args.


Grammar ordering

    To use ASSIGN('+='), had to put it after ADD_OP('+').
    But RELATION('==') must come after ASSIGN('=').
    This is getting messy. Can tokenizer be greedy, take longest token?  [done 2013-03-14]

    Should syntax parser do the same?   ####


2013-03-09

Greedy tokenizer

    Should tokenizer return token with the most chars, or token parsed from longest alternate?
        Could these be different?
        Longest alternate may not be most complex -- one item may be a (complex) nonterm.
        Longest token (number of chars) is easiest to document (explain).
        
    Parse all viable alternates, choose longest token (number of chars).
    
    Want to look at more examples of complex token specs to get this right.
        FLOAT is most complex so far. 
        
        Octal constants: digit strings starting with '0'
            Used in C, Python. Java?
            Seems LLVM does not have an octal constant.
                Nor a hex integer constant!? (only floats?)
            
        Hexadecimal with "0x" prefix?
    

Interesting quotes from http://clang.llvm.org/features.html :

    [Use the LLVM 'BSD' License]
    Further, nobody makes money on compilers these days, but many people need them to get bigger goals accomplished: it makes sense for everyone to work together.
    
    [Conformance with C/C++/ObjC and their variants]
    When you start work on implementing a language, you find out that there is a huge gap between how the language works and how most people understand it to work. This gap is the difference between a normal programmer and a (scary? super-natural?) "language lawyer", who knows the ins and outs of the language and can grok standardese with ease.
    
    
2013-03-10

Grammar syntax

    Could use '|' at start of production to signify an alternate of previous nonterm.
        But seems unnecessary syntactic sugar. Usually there are few alternates.
        And I think repeating the nonterm reminds us that additional productions for this nonterm may appear in other files.


2013-03-14

Fixed compiler to output comments from arg nodes.

Can't recognize multi-line comment yet, tokens don't span end of line.  ####

Tokenizer now matches longest token, regardless of order of alternates or nonterms.
    Might be confusing if syntax parser doesn't do the same.  ####


Changed base.defn to handle various number literals (restored oparg => '&' nonterm):

    literal(number)
        const &number
        
But the comment in simplepy.L0 was lost in the process. Fix this.  [done 2013-03-19]
    Should comments be associated with lines, not nodes?


eof.C0 :  no error, no code?  [fixed 2013-03-19]


2013-03-19

Rewrote comment handling to output comments immediately after code from same line.
    (Comments associated with lines, not nodes.)
    ### Extra comments after code in squares.C0 not copied.

Importing of files disabled by default in SyntaxParser and Tokenizer.
    Not normally used for source files.
    Enabled for parsing defn specs.
    This was done because new comment handling can't deal with imported files.

Syntax error at end of file now caught (eof.C0).

To Do:  ###
    Add ++ and -- operators to C0.
    Compile functions.


2013-03-20

Increment (++) and decrement (--) operators added to C0 specs.


Grammar ordering (greedy syntax parser)

    Added syntax for increment/decrement operators to C0.syntax, extending the spec for atom which appears in expr.syntax. Parser did not find "atom => variable INC_OP", because "atom => variable" comes first. Seems a good example of the need for greedy syntax parsing. To extend imported specs without ordering complications, parser must try later alternates to see if they consume more tokens, which we assume to be a better parse.

Modified parser to try all alternates, keep the last that parses the most tokens.

What if a later alternate uses the same (number of) tokens? Which should parser keep?
    (This is not an issue in tokenizer: which alternate doesn't matter, only nonterm.)
    Choosing the first seems simpler.
        Easier (quicker) to analyze productions this way.
    Choosing the last allows later specs to modify behavior.
        This might be useful, but also adds complexity. (Example?)
    Let's look at examples.
    
    This one showed up as a bug when first testing new parser.
            instruction => branch NEWLINE
            instruction => operation NEWLINE
        Parser chose operation, instead of the more specific branch.
        Easy to reorder these here, but not if branch were added in a later spec.
        This can be fixed with KEYWORD => 'br', to prevent branch being parsed as an operation.    
    
    Not clear that latest alternate is better, let's stick with first.
        Seems harder to make parse_nonterm() use first alternate.
        Better to do this now, see if any reason to change; easy to change back.
        Should clarify code as well (numtokens >= maxtokens is a bit tricky).

Revised parse_nonterm() to keep first alternate that parses the most tokens.


2013-03-21

To Do:  ###
    Use Location class to simplify error reporting.
    
Before tackling the compilation of functions, I want to see if I can generate LLVM code, which has good support for functions and other code generation needs. Been thinking about it, may be easier than I feared. 

Performance (parsing speed)
    
    Might be able to improve performance by caching tree branches, keyed by token sequences.


Looking for a standard for representation of AST (as XML).
    Found OMG (Object Management Group) Abstract Syntax Tree Metamodel.
        May be useful for writing shared defn specs.
    
Also discovered the "DMS Software Reengineering Toolkit" of Semantic Designs, Inc.
    (DMS is Design Maintenance System)
    Commercial tools for analysis and transformation of large codebases.
    Some of their tools look quite similar to what I am implementing (and much more mature).


Revised syntax parser to report error for an ambiguous parse.
    Added debug switch 'a' to allow it.
        But compiler ignores debug switches when loading defn_grammar.
            Run syntax.py on a defn spec to use debug switches.
    Make it a warning instead?  ###

Added OPCODE => 'br' to defn.tokens (before LOWERNAME), to disambiguate branch instruction.


To Do: Factor syntax_error() out of SyntaxParser.parse() -- again!   ####



