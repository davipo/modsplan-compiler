# rho2.syntax
# Modsplan syntax specification for parsing Rholang alternative syntax

use expr        # import common expression syntax from expr.syntax


block.root => process*      # root node of parse tree
process => NEWLINE

# send processes
process => send         # one-time send
process => sendr        # repeated (persistent) send

# block processes
process => newblock
process => match

# block receive processes
process => when         # one-time receive, receiver pays
process => whenever     # persistent repeated receive, receiver pays
process => contract     # persistent repeated receive, sender pays
process => select       # one of multiple receive cases matched


send => channel '.' 'send' '(' test,* ')'       # one-time send
sendr => channel '.' 'sendr' '(' test,* ')'     # repeated (persisting) send
# "test" is an expression, defined in expr.syntax

channel => atom     # "atom" from expr.syntax


newblock => 'new' variable,* body
# creates unique unforgeable values, bound to variables for use in body
# variables visible only in body, any with same name are shadowed

body => ':' NEWLINE+ INDENT block DEDENT


match => 'match' test ':' NEWLINE+ INDENT matchcase+ DEDENT
matchcase => pattern '=>' NEWLINE+ INDENT block DEDENT
# evaluates test, executes block of first matching pattern

pattern => constant             # matches value
pattern => variable             # matches anything, is bound to value
pattern => '(' test ')'         # test is evaluated, match its value
pattern => WILDCARD             # match anything, discard value
pattern => '[' patternlist ']'  # matches a list of matching elements
patternlist => pattern,* remainder?
remainder => '...' variable     # variable gets list of remaining values


when => 'when' receipt,+ rcvcondition? body   # receive once, receiver pays

receipt => channel '.' 'rcv' '(' patternlist ')'
rcvcondition => '\b,' 'if' test     # requires boolean test

# persistent repeated receives
whenever => 'whenever' receipt,+ rcvcondition? body     # receiver pays
contract => 'contract' receipt body                     # sender pays

select => 'select' ':' NEWLINE+ INDENT branch* DEDENT
branch => 'case' receipt,* body


nottest => NOT_OP comparison        # boolean 'not', used in expr.syntax


# collections (atom defined in expr.syntax, extended here)
atom => list
atom => set
atom => map
list => '[' test,* ']'
set => 'set' '(' test,* ')'
map => '{' keyvaluepair,* '}'
keyvaluepair => test ':' test
