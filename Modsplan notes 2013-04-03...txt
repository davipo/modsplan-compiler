Modsplan notes 2013-04-03..


Took a break from Modsplan to work on TopCoder Marathon programming contest "SnowCleaning".


Generating LLVM IR

Been thinking about ways to compile to LLVM IR.

I want .defn specs to use a much simpler language, based on a stack VM seems best.
    The defn language must be easy to learn.
        I want to insulate most Modsplan users from the complexity of LLVM.
    The generated code should be viewable in the stack VM language, for debugging the defn.

So I don't want to modify the compiler to output LLVM IR directly.
    That would specialize my compiler for LLVM; 
        I'd rather allow Modsplan to target any processor, without needing an LLVM backend.
    But I think we need the features of LLVM to compile aggregate types, functions, etc.

Actually, the .defn language consists of two languages:
    The defn spec language, with signatures, expansions, etc.;
        and the target operations, which may be any code.
    Can we factor out the defn spec, and import it from target spec?   ###
    For best reuse of defn specs, I want to standardize on an easy target.
        So my target is a simplified dialect of LLVM, "stackvm".

Target operations
    Can Modsplan generate code directly for another target besides stackvm?
        Operations may be in any (assembler) language, with some constraints:
            Syntax must be:
                operation => opcode oparg,*
                Can be modified somewhat in defn spec (defn.tokens, defn.syntax).
                    Compiler recognizes instruction types, arg types, 'oparg', 'carg'.
            Branch instructions must be defined in defn.syntax, to process labels properly:
                branch => 'br' label,+
    I think stackvm must be one of my specification languages (tokens, syntax, defn/stackvm).
        Need to standardize for compatible, reusable definition specs.
        It can be translated to other targets, either through LLVM or directly.
    
Seems we need both stackvm and LLVM output.
    Can I use my compiler to translate stackvm to LLVM?
        That would be another nice example of using my own compiler,
            and help me test it and develop it further.
        We'll need some clever compiler directives to make that work.
        Worth a try!
    That way we can have both kinds of output,
            and demonstrate translation from one low level language to another.
        Would users be able to translate stackvm to their own processor instructions?
            Maybe. Probably not easy to do functions and types without LLVM.
    

This brings back an issue I've mentioned in earlier notes:
    Naming of defn specs for different targets.
    <lang>.defn is the main defn spec in my defn language, which includes stackvm.
    Do we need any other naming to compile to other targets?
        Not now. Everything is compiled to stackvm, or a variation of it.
    
    To use the Modsplan compiler to translate stackvm to LLVM, we'll specify:
        stackvm.{tokens, syntax, defn}
    The defn will contain a lot of compiler directives to output LLVM instructions.
        See if this is sufficient, without stretching the specification language too much.
        

Naming of values
    How shall we name intermediate values?
    I'd like to use something recognizable from source or syntax, with the line number.
        (Labels use the label name from .defn, with line number.)
    But compilation to stkvm code loses such info.
        Could use a compiler directive to save it.
        Or just name intermediate values by the operation that produces them.
    
        


