Modsplan notes 2013-04-03..


Took a break from Modsplan to work on TopCoder Marathon programming contest "SnowCleaning".


Generating LLVM IR

Been thinking about ways to compile to LLVM IR.

I want .defn specs to use a much simpler language, based on a stack VM seems best.
    The defn language must be easy to learn.
        I want to insulate most Modsplan users from the complexity of LLVM.
    The generated code should be viewable in the stack VM language, for debugging the defn.

So I don't want to modify the compiler to output LLVM IR directly.
    That would specialize my compiler for LLVM; 
        I'd rather allow Modsplan to target any processor, without needing an LLVM backend.
    But I think we need the features of LLVM to compile aggregate types, functions, etc.

Actually, the .defn language consists of two languages:
    The defn spec language, with signatures, expansions, etc.;
        and the target operations, which may be any code.
    Can we factor out the defn spec, and import it from target spec?   ###
    For best reuse of defn specs, I want to standardize on an easy target.
        So my target is a simplified dialect of LLVM, "stackvm".

Target operations
    Can Modsplan generate code directly for another target besides stackvm?
        Operations may be in any (assembler) language, with some constraints:
            Syntax must be:
                operation => opcode oparg,*
                Can be modified somewhat in defn spec (defn.tokens, defn.syntax).
                    Compiler recognizes instruction types, arg types, 'oparg', 'carg'.
            Branch instructions must be defined in defn.syntax, to process labels properly:
                branch => 'br' label,+
    I think stackvm must be one of my specification languages (tokens, syntax, defn/stackvm).
        Need to standardize for compatible, reusable definition specs.
        It can be translated to other targets, either through LLVM or directly.
    
Seems we need both stackvm and LLVM output.
    Can I use my compiler to translate stackvm to LLVM?
        That would be another nice example of using my own compiler,
            and help me test it and develop it further.
        We'll need some clever compiler directives to make that work.
        Worth a try!
    That way we can have both kinds of output,
            and demonstrate translation from one low level language to another.
        Would users be able to translate stackvm to their own processor instructions?
            Maybe. Probably not easy to do functions and types without LLVM.
    

This brings back an issue I've mentioned in earlier notes:
    Naming of defn specs for different targets.
    <lang>.defn is the main defn spec in my defn language, which includes stackvm.
    Do we need any other naming to compile to other targets?
        Not now. Everything is compiled to stackvm, or a variation of it.
    
    To use the Modsplan compiler to translate stackvm to LLVM, we'll specify:
        stackvm.{tokens, syntax, defn}
    The defn will contain a lot of compiler directives to output LLVM instructions.
        See if this is sufficient, without stretching the specification language too much.
        

Naming of values
    How shall we name intermediate values?
    I'd like to use something recognizable from source or syntax, with the line number.
        (Labels use the label name from .defn, with line number.)
    But compilation to stkvm code loses such info.
        Could use a compiler directive to save it.
        Or just name intermediate values by the operation that produces them.


2013-04-10

Studied llvm-py and its newer incarnation, llvmpy.
Could we specify LLVM structures (types, values, functions, blocks, etc) directly in .defn? 
    This could avoid stackvm and the problem of translating it to llvm.
    But stackvm may be easier for users to understand.
    It would also tie Modsplan to LLVM.
    

2013-04-12

Sticking with stackvm for now.
    Keep it simple, easy to use.
    Borrow instructions from LLVM, but not much more.
        (Will use function definition syntax, maybe declare.)


Variables in stackvm
    Allocate and name a storage location with
        alloca <type> <identifier>
    Then use "load <identifier>", "store <identifier>".
    For assignments, do we need "getaddr <identifier>"?


Functions in stackvm

    For a function definition, we could write code to store parameters,
            so they can be accessed the same as variables.
        Can this code reside in stackvm.defn?
        Maybe this can be avoided?

    Probably best to use (simplified) LLVM syntax for function definitions in stackvm.
    
    Should we use "declare" for external function declarations?
    
    
2013-04-13

    Very frustrated by incomplete LLVM Language Reference.
        What is syntax for global variable declarations?
    
    What is a function declaration?
        Is "declare" always an external declaration?
        Is it sometimes a forward declaration of a function in the same module?
    
    Can a named function type be used in a function definition or declaration?
        I guess not.

    
2013-04-14

SBIL: Stack-Based Intermediate Language

    Need a well-defined Intermediate Representation,
        which can be easily translated to LLVM.
        
    Extend stackvm with variables.
        Use subscripting for indexing aggregates.
        Use assignment statements?
            No -- better not to mix paradigms.
            Load and store are usual for stack-based instructions.
                These are needed, best to access variables in just one way.
    
    SBIL declarations
        const, var, func, type
        
    Variables (and named constants) must be declared before use.
        (Dynamic languages will need namespace lookup,
            which can handle creating a variable when first assigned.)

    Wrote first draft of sbil.syntax.
    

2013-04-15
    
    First draft of SBIL included syntax for easy access to stack values:
        value => '$' integer    # stack value (0 = top)
    But this is not needed in defn specs. Can use "store tmp" and reference tmp instead.
    Character symbols are scarce, let's conserve them.
    I'm also concerned that '$' may not be easy to type on keyboards around the world.
    Removed it from sbil.syntax.
    
    First draft of SBIL used explicit opargs, instead of getting them from stack.
        This is good for writing code manually, but not so useful in defn specs.
            (All values are created by processing terminal nodes, leaving result on stack.)
        Changed it back to use stackvm syntax, no opargs.
    
    Need to rewrite defn specs to find best syntax for SBIL.


    Externals
        Built-in functions can be imported automatically into every sbil module.
        
        How to handle externals?
            Follow C?
            
            
2013-04-16

Decided to focus on a C modspec, since C should translate to LLVM best,
    and this will help me design SBIL to carry the necessary intermediate info.

C syntax is maddening! Was it designed to obfuscate?

Seems that parameters in a C function declaration (not definition) can be just a type,
    or a type with a name.
The syntax uses an abstract_declarator for this.
    Too complicated, I'll leave that out for now.
    

2013-04-17

The syntax of LLVM Assembly Language is not well documented, either.
    It's easier than C, though.
    
Wrote llvm.syntax because I need to specify the target I'm compiling for,
    and as a step toward writing a semantically useful C syntax.


2013-04-19

Been thinking about a way to generate LLVM directly from defn spec and parse tree.
    Can we specify LLVM objects at nodes in tree, link them using tree structure?
As far as I can tell now, seems this would be equivalent to using SBIR,
    but using a functional programming style syntax for defn spec.
I don't like a lot of parentheses; that's my best excuse for not pursuing this now.  :-)
    But really, it's hard to think about, my brain prefers an easier path.
    Probably circle back to this again later.  ###


Function declarations

Seems the only purpose of declaring a function before defining it is for type checking.
    Type checking could be done at any level:
        when generating SBIL, translating to LLVM, by LLVM itself, or at runtime.

Function declarations are used for forward declarations, and for external declarations.

Forward declarations:
    We should check these for languages that use them, but otherwise don't need them.
    
    In LLVM (and SBIL), all functions are defined globally.
        This makes it easy to extract their signatures in a preliminary pass,
            and check call signatures against them.
    (Forward declarations only needed for calls that occur before their function definition,
        used for recursive or mutually-recursive functions.)

External declarations:
    Needed to link to libraries and built-in functions, for I/O.
    Could postpone dealing with them by prepending declarations of builtins to LLVM code.
        That will allow use of printf(), puts(), etc.

Let's focus on handling function definitions first.












